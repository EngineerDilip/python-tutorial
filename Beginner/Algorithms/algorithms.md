# Algorithms

### 1\. **Sorting Algorithms**

*   **Bubble Sort**: A simple comparison-based sorting algorithm.
    
*   **Selection Sort**: Finds the minimum element and places it at the start.
    
*   **Insertion Sort**: Builds the sorted array one element at a time.
    
*   **Merge Sort**: A divide-and-conquer algorithm that divides the array and merges them.
    
*   **Quick Sort**: Another divide-and-conquer algorithm that selects a pivot element and partitions the array.
    

### 2\. **Searching Algorithms**

*   **Linear Search**: Checks each element until the desired one is found.
    
*   **Binary Search**: Efficiently searches a sorted array by dividing the search interval in half.
    

### 3\. **Recursion**

*   **Factorial Calculation**: A classic example of recursion.
    
*   **Fibonacci Sequence**: Another example that demonstrates recursive function calls.
    
*   **Tower of Hanoi**: A famous problem to understand recursion in depth.
    

### 4\. **Dynamic Programming (DP)**

*   **Fibonacci Sequence (Optimized)**: Using memoization or tabulation to optimize recursion.
    
*   **Knapsack Problem**: A popular DP problem to understand optimization.
    
*   **Longest Common Subsequence**: A string comparison problem that uses DP.
    
*   **Coin Change Problem**: A problem to make change using the minimum number of coins.
    

### 5\. **Greedy Algorithms**

*   **Fractional Knapsack Problem**: A greedy approach to solve the knapsack problem.
    
*   **Activity Selection Problem**: Selects the maximum number of activities without overlap.
    
*   **Huffman Coding**: A greedy algorithm for lossless data compression.
    

### 6\. **Divide and Conquer**

*   **Merge Sort**: Divides the array into sub-arrays and merges them after sorting.
    
*   **Quick Sort**: Selects a pivot and partitions the array recursively.
    
*   **Binary Search**: Efficiently searches a sorted array using the divide-and-conquer strategy.
    

### 7\. **Backtracking**

*   **N-Queens Problem**: A famous problem to place queens on a chessboard without conflict.
    
*   **Sudoku Solver**: Uses backtracking to solve the Sudoku puzzle.
    
*   **Subset Sum Problem**: Finds subsets of numbers that add up to a target.
    

### 8\. **Graph Algorithms**

*   **Breadth-First Search (BFS)**: A graph traversal algorithm that explores neighbors level by level.
    
*   **Depth-First Search (DFS)**: Explores as far as possible along each branch before backtracking.
    
*   **Dijkstra's Algorithm**: Finds the shortest path in a graph with non-negative weights.
    
*   **Kruskal's Algorithm**: A greedy algorithm for finding the minimum spanning tree.
    
*   **Prim's Algorithm**: Another algorithm for finding the minimum spanning tree.
    

### 9\. **Mathematical Algorithms**

*   **Prime Number Check**: Check whether a number is prime.
    
*   **Greatest Common Divisor (GCD)**: Using Euclid's algorithm.
    
*   **Sieve of Eratosthenes**: An efficient algorithm to generate prime numbers.
    
*   **LCM (Least Common Multiple)**: Using the relationship between GCD and LCM.
    

### 10\. **String Algorithms**

*   **Palindrome Check**: Determine whether a string reads the same backward.
    
*   **Anagram Check**: Check if two strings are anagrams of each other.
    
*   **String Search (KMP Algorithm)**: Efficient pattern matching.
    
*   **Longest Common Substring**: Finds the longest substring that appears in two strings.
    

### 11\. **Bit Manipulation**

*   **Bitwise AND, OR, XOR**: Basic bitwise operations.
    
*   **Check if a Number is Power of Two**: Using bitwise operations.
    
*   **Count Set Bits in a Number**: Using efficient bit manipulation techniques.
    

### 12\. **Linked Lists Algorithms**

*   **Reversing a Linked List**: Reverse a singly linked list.
    
*   **Cycle Detection (Floydâ€™s Tortoise and Hare)**: Detect cycles in a linked list.
    
*   **Merge Two Sorted Linked Lists**: Merging two sorted lists into one.
    

### 13\. **Hashing Algorithms**

*   **Hash Maps and Sets**: Using dictionaries to solve problems like counting frequency.
    
*   **Two Sum Problem**: Using hashing to find pairs that sum up to a target.
    
*   **Finding Duplicates**: Using hash maps to detect duplicate elements in an array.
    

### 14\. **Tree Algorithms**

*   **Binary Tree Traversal**: Pre-order, in-order, post-order, and level-order traversal.
    
*   **Binary Search Tree (BST)**: Operations like insertion, deletion, and search.
    
*   **Lowest Common Ancestor**: Find the lowest common ancestor of two nodes in a tree.
    
*   **Balanced Trees (AVL, Red-Black Trees)**: Algorithms for maintaining balanced trees.
    

### 15\. **Heap Algorithms**

*   **Min Heap and Max Heap**: Operations such as insertion, deletion, and heapify.
    
*   **Heap Sort**: A sorting algorithm that uses heap data structures.
    
*   **Priority Queue**: Using a heap to implement a priority queue efficiently.